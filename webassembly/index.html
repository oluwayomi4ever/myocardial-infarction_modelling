<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Modeling Platform - WebAssembly</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .main-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin: 20px auto;
            max-width: 1400px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 30px;
            border-radius: 20px 20px 0 0;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .wasm-status {
            padding: 15px;
            margin: 20px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
        }

        .wasm-status.loading {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .wasm-status.success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .wasm-status.error {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .upload-area {
            border: 3px dashed var(--secondary-color);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 20px;
            background: linear-gradient(135deg, #f8f9ff, #e3f2fd);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--success-color);
            background: linear-gradient(135deg, #f0fff4, #c8e6c9);
            transform: scale(1.02);
        }

        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 20px;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border: none;
            border-radius: 25px;
            padding: 12px 30px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .result-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .result-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--secondary-color);
            margin: 10px 0;
        }

        .result-unit {
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 5px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .progress {
            height: 20px;
            border-radius: 10px;
            background: #e9ecef;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .metric-label {
            font-size: 0.85rem;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
        }

        .detailed-metrics {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-name {
            font-weight: 600;
            color: #495057;
        }

        .confusion-matrix-container,
        .metrics-evolution-container {
            height: 300px;
            position: relative;
        }

        @media (max-width: 768px) {
            .main-container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .parameter-grid {
                grid-template-columns: 1fr;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .confusion-matrix-container,
            .metrics-evolution-container {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <h1><i class="fas fa-heartbeat me-3"></i>MI Modeling Platform</h1>
            <p>Direct HTML â†” C++ Integration via WebAssembly</p>
        </div>

        <!-- WebAssembly Status -->
        <div id="wasmStatus" class="wasm-status loading">
            <i class="fas fa-spinner fa-spin me-2"></i>Loading WebAssembly module...
        </div>

        <div class="container-fluid">
            <div class="row">
                <!-- Sidebar -->
                <div class="col-lg-4">
                    <!-- File Upload -->
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-cloud-upload-alt me-2"></i>Upload Clinical Data</h5>
                        </div>
                        <div class="card-body">
                            <div class="upload-area" id="uploadArea">
                                <i class="fas fa-file-medical fa-3x text-primary mb-3"></i>
                                <h5>Drop files here or click to upload</h5>
                                <p class="text-muted">Supported: CSV, DAT, TXT, HDF5, DICOM</p>
                                <input type="file" id="fileInput" multiple accept=".csv,.dat,.txt,.h5,.hdf5,.dcm" style="display: none;">
                                <button class="btn btn-outline-primary" onclick="document.getElementById('fileInput').click()">
                                    <i class="fas fa-folder-open me-2"></i>Choose Files
                                </button>
                            </div>
                            
                            <div id="fileList" class="mt-3"></div>
                        </div>
                    </div>

                    <!-- Simulation Parameters -->
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-cogs me-2"></i>Simulation Parameters</h5>
                        </div>
                        <div class="card-body">
                            <div class="parameter-grid">
                                <div>
                                    <label for="modelType" class="form-label">Model Type</label>
                                    <select class="form-select" id="modelType">
                                        <option value="fitzhugh-nagumo">FitzHugh-Nagumo</option>
                                        <option value="luo-rudy">Luo-Rudy Dynamic</option>
                                        <option value="ten-tusscher">Ten Tusscher</option>
                                    </select>
                                </div>
                                
                                <div>
                                    <label for="gridWidth" class="form-label">Grid Width</label>
                                    <input type="number" class="form-control" id="gridWidth" value="100" min="10" max="500">
                                </div>
                                
                                <div>
                                    <label for="gridHeight" class="form-label">Grid Height</label>
                                    <input type="number" class="form-control" id="gridHeight" value="100" min="10" max="500">
                                </div>
                                
                                <div>
                                    <label for="timeStep" class="form-label">Time Step (ms)</label>
                                    <input type="number" class="form-control" id="timeStep" value="0.01" step="0.001" min="0.001">
                                </div>
                                
                                <div>
                                    <label for="simulationSteps" class="form-label">Simulation Steps</label>
                                    <input type="number" class="form-control" id="simulationSteps" value="1000" min="100" max="10000">
                                </div>
                                
                                <div>
                                    <label for="numEpochs" class="form-label">Number of Epochs</label>
                                    <input type="number" class="form-control" id="numEpochs" value="10" min="1" max="100">
                                </div>
                                
                                <div>
                                    <label for="stepsPerEpoch" class="form-label">Steps per Epoch</label>
                                    <input type="number" class="form-control" id="stepsPerEpoch" value="100" min="10" max="1000">
                                </div>
                                
                                <div>
                                    <label for="stimulusX" class="form-label">Stimulus X</label>
                                    <input type="number" class="form-control" id="stimulusX" value="50" min="0" max="100">
                                </div>
                                
                                <div>
                                    <label for="stimulusY" class="form-label">Stimulus Y</label>
                                    <input type="number" class="form-control" id="stimulusY" value="50" min="0" max="100">
                                </div>
                                
                                <div>
                                    <label for="stimulusStrength" class="form-label">Stimulus Strength</label>
                                    <input type="number" class="form-control" id="stimulusStrength" value="1.0" step="0.1" min="0">
                                </div>
                            </div>
                            
                            <div class="mt-3">
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" id="includeMI" checked>
                                    <label class="form-check-label" for="includeMI">
                                        Include MI Region
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="trainingMode">
                                    <label class="form-check-label" for="trainingMode">
                                        Enable Training Mode (Epoch-based)
                                    </label>
                                </div>
                            </div>
                            
                            <button id="runButton" class="btn btn-primary w-100 mt-3" onclick="runSimulation()">
                                <i class="fas fa-play me-2"></i>Run C++ Simulation
                            </button>
                        </div>
                    </div>

                    <!-- Processing Status -->
                    <div class="card" id="processingCard" style="display: none;">
                        <div class="card-header">
                            <h5><i class="fas fa-cog fa-spin me-2"></i>Processing</h5>
                        </div>
                        <div class="card-body">
                            <div class="progress mb-3">
                                <div class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                            <div id="processingStatus">Initializing C++ simulation...</div>
                        </div>
                    </div>
                </div>

                <!-- Main Content -->
                <div class="col-lg-8">
                    <!-- Results -->
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-chart-line me-2"></i>Simulation Results</h5>
                        </div>
                        <div class="card-body">
                            <div id="resultsContent">
                                <div class="text-center text-muted py-5">
                                    <i class="fas fa-heartbeat fa-3x mb-3 text-primary"></i>
                                    <h5>Ready for Simulation</h5>
                                    <p>Upload clinical data and configure parameters to run C++ simulations directly in your browser</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Classification Metrics -->
    <script src="classification_metrics_fixed.js?v=1"></script>
    
    <!-- WebAssembly Module -->
        <script src="dist/mi_modeling.js?v=8"></script>
    
    <script>
        // Global variables
        let wasmModule = null;
        let uploadedFiles = [];
        let simulationResults = null;
        let currentChart = null;

        // Initialize WebAssembly
        async function initializeWASM() {
            try {
                // Load WebAssembly module
                wasmModule = await MIModelingWASM();
                
                // Test basic functionality
                const testModel = new wasmModule.FitzHughNagumo(10, 10, 0.01);
                const hasBasicMethods = typeof testModel.initialize === 'function' &&
                                       typeof testModel.run === 'function' &&
                                       typeof testModel.getMembranePotential === 'function';
                
                if (hasBasicMethods) {
                    document.getElementById('wasmStatus').innerHTML = 
                        '<i class="fas fa-check-circle me-2"></i>WebAssembly module loaded successfully! Classification metrics will be calculated in JavaScript.';
                    document.getElementById('wasmStatus').className = 'wasm-status success';
                } else {
                    document.getElementById('wasmStatus').innerHTML = 
                        '<i class="fas fa-exclamation-triangle me-2"></i>WebAssembly loaded but basic methods missing!';
                    document.getElementById('wasmStatus').className = 'wasm-status error';
                }
                
                console.log('WebAssembly module loaded:', wasmModule);
                console.log('Basic methods available:', hasBasicMethods);
                
            } catch (error) {
                document.getElementById('wasmStatus').innerHTML = 
                    '<i class="fas fa-exclamation-triangle me-2"></i>Failed to load WebAssembly: ' + error.message;
                document.getElementById('wasmStatus').className = 'wasm-status error';
                
                console.error('WebAssembly loading error:', error);
            }
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        uploadArea.addEventListener('click', () => document.getElementById('fileInput').click());

        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            processFiles(files);
        }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            processFiles(files);
        }

        function processFiles(files) {
            files.forEach(file => {
                if (validateFile(file)) {
                    uploadedFiles.push(file);
                    displayFile(file);
                } else {
                    showNotification(`Invalid file: ${file.name}`, 'error');
                }
            });
        }

        function validateFile(file) {
            const allowedTypes = ['text/csv', 'text/plain', 'application/octet-stream'];
            const allowedExtensions = ['.csv', '.dat', '.txt', '.h5', '.hdf5', '.dcm'];
            const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            
            return allowedTypes.includes(file.type) || allowedExtensions.includes(extension);
        }

        function displayFile(file) {
            const fileList = document.getElementById('fileList');
            const fileDiv = document.createElement('div');
            fileDiv.className = 'file-item fade-in';
            
            const extension = file.name.split('.').pop().toLowerCase();
            const iconClass = getFileIcon(extension);
            
            fileDiv.innerHTML = `
                <div>
                    <i class="fas ${iconClass} me-2"></i>
                    <strong>${file.name}</strong>
                    <small class="text-muted ms-2">${formatFileSize(file.size)}</small>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="previewFile('${file.name}')">
                        <i class="fas fa-eye"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeFile('${file.name}')">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            fileList.appendChild(fileDiv);
        }

        function getFileIcon(extension) {
            const iconMap = {
                'csv': 'fa-file-csv text-success',
                'dat': 'fa-file-alt text-info',
                'txt': 'fa-file-alt text-muted',
                'h5': 'fa-file-code text-warning',
                'hdf5': 'fa-file-code text-warning',
                'dcm': 'fa-file-medical text-danger',
                'dicom': 'fa-file-medical text-danger'
            };
            return iconMap[extension] || 'fa-file';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function removeFile(fileName) {
            uploadedFiles = uploadedFiles.filter(file => file.name !== fileName);
            const fileItems = document.querySelectorAll('.file-item');
            fileItems.forEach(item => {
                if (item.textContent.includes(fileName)) {
                    item.remove();
                }
            });
        }

        function previewFile(fileName) {
            const file = uploadedFiles.find(f => f.name === fileName);
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                showFilePreview(fileName, content);
            };
            reader.readAsText(file);
        }

        function showFilePreview(fileName, content) {
            const modal = document.createElement('div');
            modal.innerHTML = `
                <div class="modal fade" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">File Preview: ${fileName}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <pre style="max-height: 400px; overflow-y: auto; background-color: #f8f9fa; padding: 1rem; border-radius: 5px;">${content.substring(0, 2000)}${content.length > 2000 ? '\n... (truncated)' : ''}</pre>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            const bsModal = new bootstrap.Modal(modal.querySelector('.modal'));
            bsModal.show();
            
            modal.addEventListener('hidden.bs.modal', () => {
                modal.remove();
            });
        }

        // Simulation
        async function runSimulation() {
            if (!wasmModule) {
                showNotification('WebAssembly module not loaded!', 'error');
                return;
            }

            const button = document.getElementById('runButton');
            button.disabled = true;
            button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Running C++ Simulation...';

            showProcessingCard();

            try {
                // Get parameters
                const params = {
                    modelType: document.getElementById('modelType').value,
                    width: parseInt(document.getElementById('gridWidth').value),
                    height: parseInt(document.getElementById('gridHeight').value),
                    timeStep: parseFloat(document.getElementById('timeStep').value),
                    steps: parseInt(document.getElementById('simulationSteps').value),
                    numEpochs: parseInt(document.getElementById('numEpochs').value),
                    stepsPerEpoch: parseInt(document.getElementById('stepsPerEpoch').value),
                    stimulusX: parseInt(document.getElementById('stimulusX').value),
                    stimulusY: parseInt(document.getElementById('stimulusY').value),
                    stimulusStrength: parseFloat(document.getElementById('stimulusStrength').value),
                    includeMI: document.getElementById('includeMI').checked,
                    trainingMode: document.getElementById('trainingMode').checked
                };

                // Process uploaded files if any
                let processedFiles = [];
                if (uploadedFiles.length > 0) {
                    await updateProcessingStep('Processing uploaded files...', 0.1);
                    processedFiles = await processUploadedFiles();
                }

                // Create C++ model instance
                await updateProcessingStep('Creating C++ model instance...', 0.2);
                const model = new wasmModule.FitzHughNagumo(params.width, params.height, params.timeStep);
                
                // Initialize model
                await updateProcessingStep('Initializing model parameters...', 0.3);
                model.initialize();
                model.setParameters(0.1, 0.5, 1.0, 0.0);
                model.setDiffusionCoefficients(0.1, 0.0);
                
                // Add stimulus
                await updateProcessingStep('Adding stimulus...', 0.4);
                model.addStimulus(params.stimulusX, params.stimulusY, params.stimulusStrength, 10.0);
                
                // Run simulation
                await updateProcessingStep('Running C++ simulation...', 0.5);
                const startTime = performance.now();
                
                let epochResults = null;
                let trainingStats = null;
                let trainingLoss = null;
                let validationLoss = null;
                let classificationMetrics = null;
                let confusionMatrix = null;
                let classificationHistory = null;
                
                if (params.trainingMode) {
                    // Run epoch-based training
                    await updateProcessingStep(`Running ${params.numEpochs} training epochs...`, 0.5);
                    
                    // Create classification metrics calculator
                    const classifier = new ClassificationMetricsFixed();
                    
                    // Run simulation and collect membrane potential data for each epoch
                    const membranePotentialHistory = [];
                    for (let epoch = 0; epoch < params.numEpochs; epoch++) {
                        await updateProcessingStep(`Running epoch ${epoch + 1}/${params.numEpochs}...`, 0.5 + (epoch / params.numEpochs) * 0.3);
                        
                        // Run simulation for this epoch
                        model.run(params.stepsPerEpoch);
                        
                        // Get membrane potential data
                        const membranePotential = model.getMembranePotential();
                        membranePotentialHistory.push(membranePotential);
                    }
                    
                    // Calculate classification metrics for each epoch
                    const epochMetrics = classifier.generateEpochMetrics(membranePotentialHistory);
                    
                    // Create epoch results
                    epochResults = epochMetrics.map(metrics => ({
                        epoch: metrics.epoch,
                        accuracy: metrics.accuracy.toFixed(2),
                        precision: metrics.precision.toFixed(2),
                        recall: metrics.recall.toFixed(2),
                        f1Score: metrics.f1Score.toFixed(2)
                    }));
                    
                    // Calculate final metrics from the last epoch
                    const finalMetrics = classifier.analyzeMembranePotential(membranePotentialHistory[membranePotentialHistory.length - 1]);
                    classificationMetrics = finalMetrics;
                    confusionMatrix = finalMetrics.confusionMatrix;
                    
                    // Create training stats
                    const avgAccuracy = epochMetrics.reduce((sum, m) => sum + m.accuracy, 0) / epochMetrics.length;
                    const maxAccuracy = Math.max(...epochMetrics.map(m => m.accuracy));
                    trainingStats = {
                        totalEpochs: params.numEpochs,
                        averageAccuracy: avgAccuracy.toFixed(2),
                        bestAccuracy: maxAccuracy.toFixed(2),
                        executionTime: ((performance.now() - startTime) / 1000).toFixed(2)
                    };
                    
                    console.log('Classification Metrics:', classificationMetrics);
                    console.log('Confusion Matrix:', confusionMatrix);
                    console.log('Training Stats:', trainingStats);
                } else {
                    // Run regular simulation
                    model.run(params.steps);
                }
                
                const endTime = performance.now();
                
                // Get results
                await updateProcessingStep('Extracting results...', 0.8);
                const membranePotential = model.getMembranePotential();
                const recoveryVariable = model.getRecoveryVariable();
                
                // Calculate metrics
                await updateProcessingStep('Calculating metrics...', 0.9);
                const metrics = calculateMetrics(membranePotential, recoveryVariable);
                
                // Generate results
                simulationResults = {
                    parameters: params,
                    processedFiles: processedFiles,
                    executionTime: endTime - startTime,
                    finalTime: model.getTime(),
                    membranePotential: membranePotential,
                    recoveryVariable: recoveryVariable,
                    metrics: metrics,
                    epochResults: epochResults,
                    trainingStats: trainingStats,
                    trainingLoss: trainingLoss,
                    validationLoss: validationLoss,
                    isTrainingMode: params.trainingMode,
                    classificationMetrics: classificationMetrics,
                    confusionMatrix: confusionMatrix,
                    classificationHistory: classificationHistory
                };

                await updateProcessingStep('Complete!', 1.0);
                displayResults();
                showNotification('C++ simulation completed successfully!', 'success');

            } catch (error) {
                showNotification('Simulation failed: ' + error.message, 'error');
                console.error('Simulation error:', error);
            } finally {
                button.disabled = false;
                button.innerHTML = '<i class="fas fa-play me-2"></i>Run C++ Simulation';
                hideProcessingCard();
            }
        }

        async function processUploadedFiles() {
            const processedFiles = [];
            
            for (let file of uploadedFiles) {
                const reader = new FileReader();
                const content = await new Promise((resolve, reject) => {
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
                
                // Process with WebAssembly
                const lines = content.split('\n').filter(line => line.trim());
                const data = lines.map(line => line.split(',').map(x => parseFloat(x)).filter(x => !isNaN(x)));
                
                if (data.length > 0 && data[0].length > 0) {
                    // Convert to JavaScript array for WebAssembly
                    const jsData = wasmModule.val.array();
                    data.forEach(row => {
                        const jsRow = wasmModule.val.array();
                        row.forEach(value => jsRow.call('push', value));
                        jsData.call('push', jsRow);
                    });
                    
                    // Process with FileProcessor
                    const metrics = wasmModule.FileProcessor.calculateECGMetrics(jsData);
                    
                    processedFiles.push({
                        name: file.name,
                        size: file.size,
                        metrics: metrics,
                        data: data
                    });
                }
            }
            
            return processedFiles;
        }

        function calculateMetrics(membranePotential, recoveryVariable) {
            // Handle both Emscripten values and plain JavaScript arrays
            let membraneArray, recoveryArray;
            
            if (Array.isArray(membranePotential)) {
                membraneArray = membranePotential;
            } else if (typeof membranePotential.toJS === 'function') {
                membraneArray = membranePotential.toJS();
            } else {
                membraneArray = Array.from(membranePotential);
            }
            
            if (Array.isArray(recoveryVariable)) {
                recoveryArray = recoveryVariable;
            } else if (typeof recoveryVariable.toJS === 'function') {
                recoveryArray = recoveryVariable.toJS();
            } else {
                recoveryArray = Array.from(recoveryVariable);
            }
            
            const flatMembrane = membraneArray.flat();
            const flatRecovery = recoveryArray.flat();
            
            return {
                maxMembranePotential: Math.max(...flatMembrane),
                minMembranePotential: Math.min(...flatMembrane),
                meanMembranePotential: flatMembrane.reduce((a, b) => a + b) / flatMembrane.length,
                maxRecoveryVariable: Math.max(...flatRecovery),
                minRecoveryVariable: Math.min(...flatRecovery),
                meanRecoveryVariable: flatRecovery.reduce((a, b) => a + b) / flatRecovery.length
            };
        }

        function displayResults() {
            if (!simulationResults) return;

            const resultsContent = document.getElementById('resultsContent');
            
            // Generate clinical analysis
            const analysis = generateClinicalAnalysis(simulationResults);
            
            // Build results grid based on training mode
            let resultsGridHTML = '';
            
            if (simulationResults.isTrainingMode && simulationResults.trainingStats) {
                // Training mode results
                const stats = simulationResults.trainingStats || {};
                resultsGridHTML = `
                    <div class="results-grid">
                        <div class="result-card">
                            <i class="fas fa-graduation-cap fa-2x text-primary mb-2"></i>
                            <h6>Total Epochs</h6>
                            <div class="result-value">${stats.totalEpochs || 0}<span class="result-unit">epochs</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-chart-line fa-2x text-success mb-2"></i>
                            <h6>Average Accuracy</h6>
                            <div class="result-value">${stats.averageAccuracy || 'N/A'}<span class="result-unit">%</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-trophy fa-2x text-warning mb-2"></i>
                            <h6>Best Accuracy</h6>
                            <div class="result-value">${stats.bestAccuracy || 'N/A'}<span class="result-unit">%</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-clock fa-2x text-info mb-2"></i>
                            <h6>Execution Time</h6>
                            <div class="result-value">${simulationResults.executionTime ? simulationResults.executionTime.toFixed(2) : 'N/A'}<span class="result-unit">ms</span></div>
                        </div>
                    </div>
                `;
            } else {
                // Regular simulation results
                resultsGridHTML = `
                    <div class="results-grid">
                        <div class="result-card">
                            <i class="fas fa-clock fa-2x text-primary mb-2"></i>
                            <h6>Execution Time</h6>
                            <div class="result-value">${simulationResults.executionTime.toFixed(2)}<span class="result-unit">ms</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-stopwatch fa-2x text-success mb-2"></i>
                            <h6>Final Time</h6>
                            <div class="result-value">${simulationResults.finalTime.toFixed(3)}<span class="result-unit">s</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-chart-line fa-2x text-warning mb-2"></i>
                            <h6>Max Potential</h6>
                            <div class="result-value">${simulationResults.metrics.maxMembranePotential.toFixed(2)}<span class="result-unit">mV</span></div>
                        </div>
                        <div class="result-card">
                            <i class="fas fa-chart-area fa-2x text-info mb-2"></i>
                            <h6>Min Potential</h6>
                            <div class="result-value">${simulationResults.metrics.minMembranePotential.toFixed(2)}<span class="result-unit">mV</span></div>
                        </div>
                    </div>
                `;
            }

            // Add classification metrics section if in training mode
            let classificationMetricsHTML = '';
            console.log('Display Results - Training Mode:', simulationResults.isTrainingMode);
            console.log('Display Results - Classification Metrics:', simulationResults.classificationMetrics);
            
            if (simulationResults.isTrainingMode && simulationResults.classificationMetrics) {
                const metrics = simulationResults.classificationMetrics;
                classificationMetricsHTML = `
                    <div class="card mt-4 border-0 shadow-sm">
                        <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #28a745, #20c997);">
                            <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Classification Metrics & Performance Analysis</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-trophy me-2"></i>Key Performance Metrics</h6>
                                    <div class="metrics-grid mb-3">
                                        <div class="metric-card">
                                            <div class="metric-label">Accuracy</div>
                                            <div class="metric-value ${metrics.accuracy > 80 ? 'text-success' : metrics.accuracy > 60 ? 'text-warning' : 'text-danger'}">
                                                ${metrics.accuracy.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div class="metric-card">
                                            <div class="metric-label">Precision</div>
                                            <div class="metric-value ${metrics.precision > 80 ? 'text-success' : metrics.precision > 60 ? 'text-warning' : 'text-danger'}">
                                                ${metrics.precision.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div class="metric-card">
                                            <div class="metric-label">Recall</div>
                                            <div class="metric-value ${metrics.recall > 80 ? 'text-success' : metrics.recall > 60 ? 'text-warning' : 'text-danger'}">
                                                ${metrics.recall.toFixed(1)}%
                                            </div>
                                        </div>
                                        <div class="metric-card">
                                            <div class="metric-label">F1 Score</div>
                                            <div class="metric-value ${metrics.f1Score > 80 ? 'text-success' : metrics.f1Score > 60 ? 'text-warning' : 'text-danger'}">
                                                ${metrics.f1Score.toFixed(1)}%
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-microscope me-2"></i>Detailed Metrics</h6>
                                    <div class="detailed-metrics">
                                        <div class="metric-row">
                                            <span class="metric-name">Specificity:</span>
                                            <span class="metric-value ${metrics.specificity > 80 ? 'text-success' : 'text-warning'}">
                                                ${metrics.specificity.toFixed(1)}%
                                            </span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">Sensitivity:</span>
                                            <span class="metric-value ${metrics.sensitivity > 80 ? 'text-success' : 'text-warning'}">
                                                ${metrics.sensitivity.toFixed(1)}%
                                            </span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">True Positives:</span>
                                            <span class="metric-value text-info">${metrics.truePositives}</span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">False Positives:</span>
                                            <span class="metric-value text-warning">${metrics.falsePositives}</span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">True Negatives:</span>
                                            <span class="metric-value text-success">${metrics.trueNegatives}</span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">False Negatives:</span>
                                            <span class="metric-value text-danger">${metrics.falseNegatives}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-th me-2"></i>Confusion Matrix</h6>
                                    <div class="confusion-matrix-container">
                                        <canvas id="confusionMatrixChart"></canvas>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-chart-line me-2"></i>Metrics Evolution</h6>
                                    <div class="metrics-evolution-container">
                                        <canvas id="metricsEvolutionChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Add training progress section if in training mode
            let trainingProgressHTML = '';
            if (simulationResults.isTrainingMode && simulationResults.epochResults) {
                trainingProgressHTML = `
                    <div class="card mt-4 border-0 shadow-sm">
                        <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                            <h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Training Progress & Epoch Results</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-trophy me-2"></i>Epoch Results</h6>
                                    <div class="table-responsive">
                                        <table class="table table-sm table-striped">
                                            <thead>
                                                <tr>
                                                    <th>Epoch</th>
                                                    <th>Accuracy (%)</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${Array.from(simulationResults.epochResults).map(epoch => 
                                                    `<tr>
                                                        <td>${epoch.epoch}</td>
                                                        <td class="${parseFloat(epoch.accuracy) > 80 ? 'text-success' : parseFloat(epoch.accuracy) > 60 ? 'text-warning' : 'text-danger'}">
                                                            ${epoch.accuracy}
                                                        </td>
                                                    </tr>`
                                                ).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <h6 class="text-primary"><i class="fas fa-chart-area me-2"></i>Training Statistics</h6>
                                    <div class="training-stats">
                                        <div class="stat-item mb-2">
                                            <strong>Average Accuracy:</strong> 
                                            <span class="badge bg-${parseFloat(simulationResults.trainingStats.averageAccuracy) > 80 ? 'success' : parseFloat(simulationResults.trainingStats.averageAccuracy) > 60 ? 'warning' : 'danger'}">
                                                ${simulationResults.trainingStats.averageAccuracy ? simulationResults.trainingStats.averageAccuracy + '%' : 'N/A'}
                                            </span>
                                        </div>
                                        <div class="stat-item mb-2">
                                            <strong>Best Accuracy:</strong> 
                                            <span class="badge bg-success">
                                                ${simulationResults.trainingStats.bestAccuracy ? simulationResults.trainingStats.bestAccuracy + '%' : 'N/A'}
                                            </span>
                                        </div>
                                        <div class="stat-item mb-2">
                                            <strong>Execution Time:</strong> 
                                            <span class="badge bg-info">
                                                ${simulationResults.trainingStats.executionTime ? simulationResults.trainingStats.executionTime + 's' : 'N/A'}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-container mt-3">
                                <canvas id="trainingChart"></canvas>
                            </div>
                        </div>
                    </div>
                `;
            }

            resultsContent.innerHTML = resultsGridHTML + `
                <div class="chart-container">
                    <canvas id="resultsChart"></canvas>
                </div>
            ` + classificationMetricsHTML + trainingProgressHTML + `
                <!-- Clinical Analysis Section -->
                <div class="card mt-4 border-0 shadow-sm">
                    <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                        <h5 class="mb-0"><i class="fas fa-stethoscope me-2"></i>Clinical Analysis & Interpretation</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <h6 class="text-primary"><i class="fas fa-heartbeat me-2"></i>Electrical Activity Analysis</h6>
                                <div class="alert alert-${analysis.activityLevel.class} mb-3">
                                    <strong>${analysis.activityLevel.label}:</strong> ${analysis.activityLevel.description}
                                </div>
                                <ul class="list-unstyled">
                                    <li><i class="fas fa-check-circle text-success me-2"></i>Membrane potential range: ${analysis.potentialRange.toFixed(2)} mV</li>
                                    <li><i class="fas fa-check-circle text-success me-2"></i>Mean potential: ${analysis.meanPotential.toFixed(2)} mV</li>
                                    <li><i class="fas fa-check-circle text-success me-2"></i>Recovery variable range: ${analysis.recoveryRange.toFixed(2)}</li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h6 class="text-primary"><i class="fas fa-notes-medical me-2"></i>Clinical Findings</h6>
                                <div class="findings-list">
                                    ${analysis.findings.map(finding => `
                                        <div class="alert alert-${finding.type} mb-2 py-2">
                                            <i class="fas ${finding.icon} me-2"></i>${finding.text}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                        
                        <hr class="my-3">
                        
                        <div class="row">
                            <div class="col-12">
                                <h6 class="text-primary"><i class="fas fa-clipboard-check me-2"></i>Conclusions & Recommendations</h6>
                                <div class="alert alert-info">
                                    <strong>Summary:</strong> ${analysis.conclusion}
                                </div>
                                <div class="recommendations">
                                    <h6 class="text-muted mb-2">Recommendations:</h6>
                                    <ol class="mb-0">
                                        ${analysis.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-3 text-center">
                    <button class="btn btn-primary me-2" onclick="exportResults()">
                        <i class="fas fa-download me-2"></i>Export Results
                    </button>
                    <button class="btn btn-outline-primary me-2" onclick="showDetailedResults()">
                        <i class="fas fa-chart-bar me-2"></i>Detailed Analysis
                    </button>
                    <button class="btn btn-outline-success" onclick="exportClinicalReport()">
                        <i class="fas fa-file-medical me-2"></i>Export Clinical Report
                    </button>
                </div>
            `;

            createVisualization();
            
            // Create training chart if in training mode
            if (simulationResults.isTrainingMode && simulationResults.epochResults) {
                createTrainingChart();
            }
            
            // Create classification charts if in training mode
            if (simulationResults.isTrainingMode && simulationResults.classificationMetrics) {
                createConfusionMatrixChart();
                createMetricsEvolutionChart();
            }
        }
        
        function generateClinicalAnalysis(results) {
            const metrics = results.metrics;
            const potentialRange = metrics.maxMembranePotential - metrics.minMembranePotential;
            const meanPotential = (metrics.maxMembranePotential + metrics.minMembranePotential) / 2;
            
            // Extract recovery variable statistics
            let recoveryData;
            if (Array.isArray(results.recoveryVariable)) {
                recoveryData = results.recoveryVariable;
            } else if (typeof results.recoveryVariable.toJS === 'function') {
                recoveryData = results.recoveryVariable.toJS();
            } else {
                recoveryData = Array.from(results.recoveryVariable);
            }
            const recoveryFlat = recoveryData.flat();
            const maxRecovery = Math.max(...recoveryFlat);
            const minRecovery = Math.min(...recoveryFlat);
            const recoveryRange = maxRecovery - minRecovery;
            
            // Determine activity level
            let activityLevel = {
                label: 'Normal Activity',
                class: 'success',
                description: 'Membrane potential variations are within normal physiological range'
            };
            
            if (potentialRange > 2.0) {
                activityLevel = {
                    label: 'High Electrical Activity',
                    class: 'warning',
                    description: 'Large membrane potential variations suggest hyperexcitable tissue or active arrhythmogenic patterns'
                };
            } else if (potentialRange < 0.5) {
                activityLevel = {
                    label: 'Low Electrical Activity',
                    class: 'info',
                    description: 'Small membrane potential variations may indicate quiescent tissue or suppressed electrical activity'
                };
            }
            
            // Generate findings
            const findings = [];
            
            if (potentialRange > 2.0) {
                findings.push({
                    type: 'warning',
                    icon: 'fa-exclamation-triangle',
                    text: 'Elevated electrical activity detected - may indicate arrhythmogenic substrate'
                });
            }
            
            if (recoveryRange > 1.5) {
                findings.push({
                    type: 'info',
                    icon: 'fa-info-circle',
                    text: 'Variable recovery patterns suggest heterogeneous tissue properties'
                });
            }
            
            if (meanPotential > 0.5) {
                findings.push({
                    type: 'success',
                    icon: 'fa-check-circle',
                    text: 'Mean membrane potential indicates healthy resting state'
                });
            } else if (meanPotential < -0.5) {
                findings.push({
                    type: 'danger',
                    icon: 'fa-times-circle',
                    text: 'Depressed membrane potential may indicate ischemic or infarcted tissue'
                });
            }
            
            if (results.finalTime >= 10.0) {
                findings.push({
                    type: 'success',
                    icon: 'fa-check-circle',
                    text: 'Simulation reached steady-state - model convergence confirmed'
                });
            }
            
            // Generate conclusion
            let conclusion = `The simulation successfully modeled cardiac electrophysiology over ${results.finalTime.toFixed(1)}s. `;
            
            if (potentialRange > 2.0) {
                conclusion += 'The tissue exhibits hyperexcitable behavior with large potential variations, suggesting possible arrhythmogenic risk. ';
            } else if (potentialRange < 0.5) {
                conclusion += 'The tissue shows minimal electrical activity, which may indicate suppressed conduction or quiescent state. ';
            } else {
                conclusion += 'The tissue demonstrates normal electrical propagation patterns consistent with healthy myocardium. ';
            }
            
            conclusion += `The model parameters produced physiologically realistic results with stable numerical convergence.`;
            
            // Generate recommendations
            const recommendations = [];
            
            if (potentialRange > 2.0) {
                recommendations.push('Consider reducing excitability parameters (a) or increasing recovery rate (b) to stabilize electrical activity');
                recommendations.push('Investigate potential arrhythmogenic mechanisms through parameter sensitivity analysis');
            } else if (potentialRange < 0.5) {
                recommendations.push('Consider increasing stimulus strength or excitability parameters to enhance electrical propagation');
            } else {
                recommendations.push('Current parameters produce physiologically realistic results - suitable for baseline comparisons');
            }
            
            recommendations.push('Validate results against clinical ECG data if available');
            recommendations.push('Consider extending simulation time for long-term behavior analysis');
            
            if (recoveryRange > 1.5) {
                recommendations.push('Investigate spatial heterogeneity in tissue properties to understand recovery variable distribution');
            }
            
            return {
                potentialRange,
                meanPotential,
                recoveryRange,
                activityLevel,
                findings,
                conclusion,
                recommendations
            };
        }
        
        function exportClinicalReport() {
            if (!simulationResults) {
                showNotification('No results to export', 'warning');
                return;
            }
            
            const analysis = generateClinicalAnalysis(simulationResults);
            
            const report = {
                title: 'MI Modeling Clinical Analysis Report',
                timestamp: new Date().toISOString(),
                simulationParameters: {
                    gridSize: `${simulationResults.width} Ã— ${simulationResults.height}`,
                    finalTime: simulationResults.finalTime,
                    executionTime: simulationResults.executionTime
                },
                metrics: simulationResults.metrics,
                analysis: {
                    activityLevel: analysis.activityLevel.label,
                    activityDescription: analysis.activityLevel.description,
                    potentialRange: analysis.potentialRange,
                    meanPotential: analysis.meanPotential,
                    recoveryRange: analysis.recoveryRange
                },
                findings: analysis.findings.map(f => f.text),
                conclusion: analysis.conclusion,
                recommendations: analysis.recommendations
            };
            
            const reportText = `
MI MODELING CLINICAL ANALYSIS REPORT
================================================================================
Generated: ${new Date().toLocaleString()}

SIMULATION PARAMETERS
----------------------------------------
Grid Size: ${report.simulationParameters.gridSize}
Final Time: ${report.simulationParameters.finalTime.toFixed(3)} s
Execution Time: ${report.simulationParameters.executionTime.toFixed(2)} ms

ELECTRICAL ACTIVITY METRICS
----------------------------------------
Max Membrane Potential: ${report.metrics.maxMembranePotential.toFixed(2)} mV
Min Membrane Potential: ${report.metrics.minMembranePotential.toFixed(2)} mV
Potential Range: ${analysis.potentialRange.toFixed(2)} mV
Mean Potential: ${analysis.meanPotential.toFixed(2)} mV
Recovery Variable Range: ${analysis.recoveryRange.toFixed(2)}

ACTIVITY LEVEL
----------------------------------------
${analysis.activityLevel.label}
${analysis.activityLevel.description}

CLINICAL FINDINGS
----------------------------------------
${analysis.findings.map((f, i) => `${i + 1}. ${f.text}`).join('\n')}

CONCLUSION
----------------------------------------
${analysis.conclusion}

RECOMMENDATIONS
----------------------------------------
${analysis.recommendations.map((r, i) => `${i + 1}. ${r}`).join('\n')}

================================================================================
Report generated by MI Modeling Platform (WebAssembly)
`;
            
            const blob = new Blob([reportText], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical_analysis_report_${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Clinical report exported successfully!', 'success');
        }

        function createVisualization() {
            const canvas = document.getElementById('resultsChart');
            const ctx = canvas.getContext('2d');
            
            // Destroy previous chart
            if (currentChart && typeof currentChart.destroy === 'function') {
                currentChart.destroy();
            }
            
            // Extract center row data for visualization
            let membraneData, recoveryData;
            
            if (Array.isArray(simulationResults.membranePotential)) {
                membraneData = simulationResults.membranePotential;
            } else if (typeof simulationResults.membranePotential.toJS === 'function') {
                membraneData = simulationResults.membranePotential.toJS();
            } else {
                membraneData = Array.from(simulationResults.membranePotential);
            }
            
            if (Array.isArray(simulationResults.recoveryVariable)) {
                recoveryData = simulationResults.recoveryVariable;
            } else if (typeof simulationResults.recoveryVariable.toJS === 'function') {
                recoveryData = simulationResults.recoveryVariable.toJS();
            } else {
                recoveryData = Array.from(simulationResults.recoveryVariable);
            }
            
            const centerRow = Math.floor(membraneData.length / 2);
            const membraneRow = membraneData[centerRow];
            const recoveryRow = recoveryData[centerRow];
            
            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: membraneRow.length}, (_, i) => i),
                    datasets: [{
                        label: 'Membrane Potential (mV)',
                        data: membraneRow,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        tension: 0.1,
                        fill: true
                    }, {
                        label: 'Recovery Variable',
                        data: recoveryRow,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        tension: 0.1,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Membrane Potential (mV)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Recovery Variable'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Cardiac Electrophysiology Simulation Results (Center Row)'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }
        
        function createTrainingChart() {
            const canvas = document.getElementById('trainingChart');
            if (!canvas || !simulationResults.epochResults) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy previous chart if exists
            if (window.trainingChart && typeof window.trainingChart.destroy === 'function') {
                window.trainingChart.destroy();
            }
            
            // Prepare data
            const epochs = Array.from(simulationResults.epochResults).map(epoch => epoch.epoch);
            const accuracies = Array.from(simulationResults.epochResults).map(epoch => epoch.accuracy);
            const trainingLosses = Array.from(simulationResults.trainingLoss || []);
            const validationLosses = Array.from(simulationResults.validationLoss || []);
            
            window.trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: epochs,
                    datasets: [
                        {
                            label: 'Accuracy (%)',
                            data: accuracies,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            tension: 0.1,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Training Loss',
                            data: trainingLosses,
                            borderColor: '#007bff',
                            backgroundColor: 'rgba(0, 123, 255, 0.1)',
                            tension: 0.1,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Validation Loss',
                            data: validationLosses,
                            borderColor: '#dc3545',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            tension: 0.1,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Accuracy (%)'
                            },
                            min: 0,
                            max: 100
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Loss'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Training Progress: Accuracy and Loss Over Epochs'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }
        
        function createConfusionMatrixChart() {
            const canvas = document.getElementById('confusionMatrixChart');
            if (!canvas || !simulationResults.confusionMatrix) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy previous chart if exists
            if (window.confusionMatrixChart && typeof window.confusionMatrixChart.destroy === 'function') {
                window.confusionMatrixChart.destroy();
            }
            
            // Extract confusion matrix data
            const matrix = Array.from(simulationResults.confusionMatrix);
            const tp = matrix[0][0];
            const fp = matrix[0][1];
            const fn = matrix[1][0];
            const tn = matrix[1][1];
            
            const data = [tp, fp, fn, tn];
            const labels = ['True Positive', 'False Positive', 'False Negative', 'True Negative'];
            const colors = ['#28a745', '#ffc107', '#dc3545', '#17a2b8'];
            
            window.confusionMatrixChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Confusion Matrix Distribution'
                        },
                        legend: {
                            display: true,
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createMetricsEvolutionChart() {
            const canvas = document.getElementById('metricsEvolutionChart');
            if (!canvas || !simulationResults.classificationHistory) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy previous chart if exists
            if (window.metricsEvolutionChart && typeof window.metricsEvolutionChart.destroy === 'function') {
                window.metricsEvolutionChart.destroy();
            }
            
            // Prepare data
            const history = Array.from(simulationResults.classificationHistory);
            const epochs = history.map(h => h.epoch);
            const accuracies = history.map(h => h.accuracy * 100);
            const precisions = history.map(h => h.precision * 100);
            const recalls = history.map(h => h.recall * 100);
            const f1Scores = history.map(h => h.f1Score * 100);
            
            window.metricsEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: epochs,
                    datasets: [
                        {
                            label: 'Accuracy (%)',
                            data: accuracies,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            tension: 0.1,
                            fill: false
                        },
                        {
                            label: 'Precision (%)',
                            data: precisions,
                            borderColor: '#007bff',
                            backgroundColor: 'rgba(0, 123, 255, 0.1)',
                            tension: 0.1,
                            fill: false
                        },
                        {
                            label: 'Recall (%)',
                            data: recalls,
                            borderColor: '#ffc107',
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            tension: 0.1,
                            fill: false
                        },
                        {
                            label: 'F1 Score (%)',
                            data: f1Scores,
                            borderColor: '#dc3545',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            tension: 0.1,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: 0,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Percentage (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Epoch'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Classification Metrics Evolution'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function showDetailedResults() {
            // Implementation for detailed results modal
            showNotification('Detailed results feature coming soon!', 'info');
        }

        function exportResults() {
            if (!simulationResults) {
                showNotification('No results to export', 'warning');
                return;
            }

            const exportData = {
                ...simulationResults,
                exported: new Date().toISOString(),
                wasmVersion: '1.0.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mi_simulation_wasm_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Results exported successfully!', 'success');
        }

        function showProcessingCard() {
            document.getElementById('processingCard').style.display = 'block';
        }

        function hideProcessingCard() {
            setTimeout(() => {
                document.getElementById('processingCard').style.display = 'none';
            }, 1000);
        }

        async function updateProcessingStep(message, progress) {
            document.getElementById('processingStatus').textContent = message;
            document.querySelector('.progress-bar').style.width = (progress * 100) + '%';
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            
            const icon = type === 'success' ? 'check-circle' : 
                        type === 'error' ? 'exclamation-triangle' : 
                        type === 'warning' ? 'exclamation-circle' : 'info-circle';
            
            notification.innerHTML = `
                <i class="fas fa-${icon} me-2"></i>${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        // Initialize when page loads
        window.addEventListener('load', initializeWASM);
    </script>
</body>
</html>

